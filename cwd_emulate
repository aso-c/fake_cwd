/*!
 * @brief Emulate "current directory" path for operating with file system
 * Header Include file
 * 	@file	cwd_emulate
 *	@author	(Solomatov A.A. (aso)
 *	Created	27.04.2024
 *	Version	0.3
 */



#pragma once


#ifndef __cplusplus
#error "The sdcard_ctrl file usable in C++ projects only."
#endif



/// Text representation mode of statbuf (directory entry information)
inline constexpr const char* statmode2txt(const struct stat* statbuf)
{
    return (S_ISLNK(statbuf->st_mode))? "symlink":
	    (S_ISDIR(statbuf->st_mode))? "directory":
	    (S_ISCHR(statbuf->st_mode))? "character device":
	    (S_ISBLK(statbuf->st_mode))? "block device":
	    (S_ISFIFO(statbuf->st_mode))? "FIFO channel":
	    (S_ISSOCK(statbuf->st_mode))? "socket":
					"(unknown type)";
}; /* statmode2txt() */

/// Text representation mode of statbuf (directory entry information)
inline constexpr const char* statmode2txt(const struct stat& statbuf)
{
    return statmode2txt(&statbuf);
}; /* statmode2txt() */



namespace fs	//-----------------------------------------------------------------------------------------------------
{
    /// if path - is absolute path
    inline bool absolute_path(const char path[]) { return (path[0] == '/'); };
    inline bool absolute_path(const std::string& path) { return !path.empty() && (path.front() == '/'); };
}; // namespace fs ----------------------------------------------------------------------------------------------------


namespace Exec //------------------------------------------------------------------------------------------------------
{

    /// Artificial CWD (current working directory)
    class CWD
    {
    public:
	CWD(std::string mountpointdef = "", char delim = '/'):
	    delimiter(delim), defmountpoint(CWD::refine(mountpointdef))
	{/*esp_log_level_set("CWD_emulating:", ESP_LOG_DEBUG);*//* for debug purposes */};


	// return current pwd (current dir) only, absent trailing slash in returned string is guaranteed
	std::string get() const;
	// return full path applied to a current dir
	std::string compose(std::string) const;
	// the pwd dir is root?
	static bool is_root(const std::string& str) { return (str == "/"); };
	bool is_root() const { return is_root(pwd);};
	// change cwd dir
	esp_err_t change(std::string path);
	// Set pwd to a ""
	void clear() { pwd.clear();};

	/// @brief Path validation - whatever the path exist or not -
	/// any subpath is a valid existing path
	/// @note method can modify fake_cwd::operative_path_buf
	bool valid(std::string);

	/// Tune-up any string for preparing as full path:
	/// - add leading symbol '/' (delimiter), if exist
	/// - remove tailing slash (delimiter), if exist
	static
	std::string refine(std::string);

	/// Force assign value for current working directory
	/// Use carefully! Possible incorrect behavior!!!
	void set(std::string);

	operator std::string() const {return get();};
	CWD& operator = (const std::string& path) {set(path); return *this;};
	CWD& operator /= (const std::string& path) {change(path); return *this;};


	const char delimiter;	//< delimiter of directory parts


    private:

	const std::string defmountpoint;
	std::string pwd;

	/// Sel log/debug level in the desired procedure
	/// Usage: call in debugging procedure: selective_log_level_set("Device::valid_path", ESP_LOG_DEBUG);*/	/* for debug purposes */
	void selective_log_level_set(const char tag[], esp_log_level_t level) {esp_log_level_set(tag, level);};

    }; /* CWD */

//    inline std::string operator + (const CWD_emulating& cwd, const std::string& path) {return cwd.compose(path);};
    inline std::string operator / ( const CWD& cwd, std::string path) {return cwd.compose(path);};

}; //--[ namespace Exec ]----------------------------------------------------------------------------------------------


//--[ cwd_emulate ]----------------------------------------------------------------------------------------------------
