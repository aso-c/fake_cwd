/*!
 * @brief Emulate "current directory" path for operating with file system
 * Header Include file
 * 	@file	cwd_emulate
 *	@author	(Solomatov A.A. (aso)
 *	Created	27.04.2024
 *	Version	0.3
 */



#pragma once


#ifndef __cplusplus
#error "The sdcard_ctrl file usable in C++ projects only."
#endif



/// Text representation mode of statbuf (directory entry information)
inline constexpr const char* statmode2txt(const struct stat* statbuf)
{
    return (S_ISLNK(statbuf->st_mode))? "+symlink+":
	    (S_ISREG(statbuf->st_mode))? "-file-":
	    (S_ISDIR(statbuf->st_mode))? "<DIR>":
	    (S_ISCHR(statbuf->st_mode))? "{character device}":
	    (S_ISBLK(statbuf->st_mode))? "{block device}":
	    (S_ISFIFO(statbuf->st_mode))? "[FIFO channel]":
	    (S_ISSOCK(statbuf->st_mode))? "/socket/":
					"(*unknown type*)";
}; /* statmode2txt() */

/// Text representation mode of statbuf (directory entry information)
inline constexpr const char* statmode2txt(const struct stat& statbuf)
{
    return statmode2txt(&statbuf);
}; /* statmode2txt() */



namespace fs	//-----------------------------------------------------------------------------------------------------
{
    /// if path - is absolute path
    inline bool absolute_path(const char path[]) { return (path[0] == '/'); };
    inline bool absolute_path(const std::string& path) { return !path.empty() && (path.front() == '/'); };
}; // namespace fs ----------------------------------------------------------------------------------------------------


namespace Exec //------------------------------------------------------------------------------------------------------
{

    /// Artificial CWD (current working directory)
    class CWD
    {
    public:
	CWD(std::string mountpointdef = "", char delim = '/', std::string _parent = "..", std::string _curr = "."):
	    delim_ch(delim), defmountpoint(CWD::refine(mountpointdef)),
	    parent_str(std::move(_parent)), current_str(std::move(_curr))
	{/*esp_log_level_set("CWD_emulating:", ESP_LOG_DEBUG);*//* for debug purposes */};


	// return current pwd (current dir) only, absent trailing slash in returned string is guaranteed
	const std::string& get() const { return pwd; };
	// return full path applied to a current dir
	std::string compose(std::string) const;
	// the pwd dir is root?
	static bool is_root(const std::string& str) { return (str == "/"); };
	bool is_root() const { return is_root(pwd);};
	// change cwd dir
	esp_err_t change(std::string path);
	// Set pwd to a ""
	void clear() { pwd.clear();};

	/// @brief Path validation - whatever the path exist or not -
	/// any subpath is a valid existing path
	/// @note method can modify fake_cwd::operative_path_buf
	bool valid(std::string);

	/// Tune-up any string for preparing as full path:
	/// - add leading symbol '/' (delimiter), if exist
	/// - remove tailing slash (delimiter), if exist
	static
	std::string refine(std::string);

	/// Force assign value for current working directory
	/// Use carefully! Possible incorrect behavior!!!
	void set(std::string);

	operator std::string() const {return get();};
	CWD& operator = (const std::string& path) {set(path); return *this;};
	CWD& operator /= (const std::string& path) {change(path); return *this;};

	/// Return std::string, contens the directory parts delimiter
	/*constexpr*/ std::string delimiter() const { return std::string(delim_ch, 1); };
	/// Desoignation of the parent directory
	constexpr const std::string& parent() const { return parent_str; };
	/// Desoignation of the current directory
	constexpr const std::string& current() const { return current_str; };

	const char delim_ch;	//< char of directory parts delimiter

	class last
	{
	public:
	    int static state() { return err; };
	    bool static is_exist() { return err == 0;};

	    bool static is_link() { return S_ISLNK(statbuf.st_mode); };
	    bool static is_reg()  { return S_ISREG(statbuf.st_mode); };
	    bool static is_dir()  { return S_ISDIR(statbuf.st_mode); };
	    bool static is_char() { return S_ISCHR(statbuf.st_mode); };
	    bool static is_block(){ return S_ISBLK(statbuf.st_mode); };
	    bool static is_fifo() { return S_ISFIFO(statbuf.st_mode); };
	    bool static is_soscket() { return S_ISSOCK(statbuf.st_mode); };
	}; /* class last */


    private:

	const std::string defmountpoint;
	std::string pwd;

	const std::string parent_str;
	const std::string current_str;

	static int err;		//< error state of the last operation compose() etc.
	static struct stat statbuf; //< file/directory existing status of the last operation compose() etc.

    }; /* CWD */

//    inline std::string operator + (const CWD_emulating& cwd, const std::string& path) {return cwd.compose(path);};
    inline std::string operator / ( const CWD& cwd, std::string path) {return cwd.compose(path);};

}; //--[ namespace Exec ]----------------------------------------------------------------------------------------------


//--[ cwd_emulate ]----------------------------------------------------------------------------------------------------
