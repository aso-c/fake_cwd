/*!
 * @brief Emulate "current directory" path for operating with file system
 * Header Include file
 * 	@file	cwd_emulate
 *	@author	(Solomatov A.A. (aso)
 *	Created	27.04.2024
 *	Version	0.3
 */



#pragma once


#ifndef __cplusplus
#error "The sdcard_ctrl file usable in C++ projects only."
#endif



/// Text representation mode of statbuf (directory entry information)
inline constexpr const char* statmode2txt(const struct stat* statbuf)
{
    return (S_ISLNK(statbuf->st_mode))? "symlink":
	    (S_ISDIR(statbuf->st_mode))? "directory":
	    (S_ISCHR(statbuf->st_mode))? "character device":
	    (S_ISBLK(statbuf->st_mode))? "block device":
	    (S_ISFIFO(statbuf->st_mode))? "FIFO channel":
	    (S_ISSOCK(statbuf->st_mode))? "socket":
					"(unknown type)";
}; /* statmode2txt() */

/// Text representation mode of statbuf (directory entry information)
inline constexpr const char* statmode2txt(const struct stat& statbuf)
{
    return statmode2txt(&statbuf);
}; /* statmode2txt() */



namespace fs	//-----------------------------------------------------------------------------------------------------
{

    /// if path - is absolute path
    inline bool absolute_path(const char path[]) { return (path[0] == '/'); };
    inline bool absolute_path(const std::string& path) { return !path.empty() && (path.front() == '/'); };

    /// Emulating of the CWD (current directory)
    class CWD_emulating
    {
    public:
//	CWD_emulating(char cwdbuff[], size_t cwdbufflen):
	CWD_emulating(char cwdbuff[], size_t cwdbufflen):
	    pwd(cwdbuff), pwd_bufflen(cwdbufflen) {/*esp_log_level_set("CWD_emulating:", ESP_LOG_DEBUG);*//* for debug purposes */};

//#pragma GCC diagnostic push
//#pragma GCC diagnostic ignored "-Wnonnull"
	// get current dir (if path == NULL or "") or generate fullpath for sended path
	// absent trailing slash in returned string is guaranteed

	// return current pwd (current dir) only, absent trailing slash in returned string is guaranteed
	std::string get() const;
	// return full path appling current dir
	std::string compose(const std::string& path) { ESP_LOGD(__PRETTY_FUNCTION__, "\"path\" argument is %s", path.c_str());
	    ESP_LOGD(__PRETTY_FUNCTION__, "\"CWD_emulating\" compose for const std::string& path, redirect to rvalue-version with temporary copy of it");
	    return compose(std::string(path)/*, path.length()*//*strlen(path)*/);
	};
	// compose the full path from the current directory for rvalue type path
	std::string compose(std::string&&);
//#pragma GCC diagnostic pop
	// raw get path with current dir:
	// only concatenate path with current dir,
	// not processing output with realpath().
	char* raw_compose(const std::string& path = "");
	// get current operative path buffer - previous stored path on it
	std::string current() {return operative_path_buff;};
	// the pwd dir is root?
	static bool is_root(const std::string& str) { return (str == "/"); };
	bool is_root() const { return is_root(pwd);};
	// change cwd dir
	esp_err_t change(const std::string& path);
	char* clearbuff() {operative_path_buff[0] = '\0'; return operative_path_buff;};	// clear operative path buffer - set it's value to ""

	/// @brief Path validation - whatever the path exist or not -
	/// any subpath is a valid existing path
	/// @note method can modify fake_cwd::operative_path_buf
	bool valid(const std::string& path) {
	    ESP_LOGW(__PRETTY_FUNCTION__, "Call the fs::CWD_emulating::valid(const std::string&) procedure, inline const std::string lvalue ref version");
	    return valid(std::string(path));};
	bool valid(std::string&&);

	operator std::string() const {return get();};
//	CWD_emulating& operator += (const std::string& path) {change(path); return this;};
	CWD_emulating& operator /= (const std::string& path) {change(path); return *this;};


    private:

	char* const pwd;	// pointer to cwd buffer
	const size_t pwd_bufflen;
	static char operative_path_buff[PATH_MAX];	/// temporary buffer for file fullpath composing

	/// Sel log/debug level in the desired procedure
	/// Usage: call in debugging procedure: selective_log_level_set("Device::valid_path", ESP_LOG_DEBUG);*/	/* for debug purposes */
	void selective_log_level_set(const char tag[], esp_log_level_t level) {esp_log_level_set(tag, level);};

    }; /* CWD_emulating */

//    std::string operator + (const CWD_emulating& cwd, const std::string& path) {return cwd.compose(path);};
    //std::string operator / (const CWD_emulating& cwd, const std::string& path) {return cwd.compose(path);};

}; //--[ namespace fs ]------------------------------------------------------------------------------------------------


//--[ cwd_emulate ]----------------------------------------------------------------------------------------------------
